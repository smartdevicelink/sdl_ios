#import <Quick/Quick.h>
#import <Nimble/Nimble.h>
#import <OCMock/OCMock.h>

#import "SDLError.h"
#import "SDLFile.h"
#import "SDLFileManager.h"
#import "SDLFileWrapper.h"
#import "SDLGlobals.h"
#import "SDLProtocolHeader.h"
#import "SDLPutFile.h"
#import "SDLPutFileResponse.h"
#import "SDLUploadFileOperation.h"
#import "SDLVersion.h"
#import "TestConnectionManager.h"
#import <zlib.h>
#import "SDLExpect.h"

@interface UploadFileOperationSpecHelpers : NSObject

+ (void)testPutFiles:(NSArray<SDLPutFile *> *)putFiles testFile:(SDLFile *)testFile mtuSize:(NSUInteger)mtuSize;

@end

@implementation UploadFileOperationSpecHelpers

/// Checks each of the PutFiles generated by the SDLUploadFileOperation to make sure all the properties (i.e. bulk data, offset, file name, etc.) were set correctly.
/// @param putFiles The PutFiles generated by the SDLUploadFileOperation
/// @param testFile The file used to generate the PutFiles
/// @param mtuSize The max allowed size for the packet generated for the PutFile
+ (void)testPutFiles:(NSArray<SDLPutFile *> *)putFiles testFile:(SDLFile *)testFile mtuSize:(NSUInteger)mtuSize {
    // Test all packets for offset, length, and data
    for (NSUInteger index = 0; index < putFiles.count; index++) {
        SDLPutFile *putFile = putFiles[index];

        NSUInteger maxBulkDataSize = [self.class testMaxBulkDataSizeForFile:testFile mtuSize:mtuSize];
        NSData *testBulkFileData = [testFile.data subdataWithRange:NSMakeRange((index * maxBulkDataSize), MIN(putFile.length.unsignedIntegerValue, maxBulkDataSize))];
        unsigned long testBulkFileDataCrc = crc32(0, testBulkFileData.bytes, (uInt)testBulkFileData.length);

        expect(putFile.offset).to(equal(@(index * maxBulkDataSize)));
        expect(putFile.persistentFile).to(equal(@NO));
        expect(putFile.sdlFileName).to(equal(testFile.name));
        expect(putFile.bulkData).to(equal(testBulkFileData));
        expect(putFile.crc).to(equal([NSNumber numberWithUnsignedLong:testBulkFileDataCrc]));

        // Length is used to inform the SDL Core of the total incoming packet size
        if (index == 0) {
            // The first putfile sent should have the full file size
            expect(putFile.length).to(equal(@([testFile fileSize])));
        } else if (index == putFiles.count - 1) {
            // The last pufile contains the remaining data size
            expect(putFile.length).to(equal(@([testFile fileSize] - (index * maxBulkDataSize))));
        } else {
            // All other putfiles contain the max data size for a putfile packet
            expect(putFile.length).to(equal(@(maxBulkDataSize)));
        }
    }
}

/// Calculates the number of PutFiles that should be generated by the SDLUploadFileOperation for the file's data.
/// @param file The file to be uploaded
/// @param mtuSize The max allowed size of packet generated for the PutFile
/// @return The number of PutFiles that should be created
+ (NSUInteger)testNumberOfPutFiles:(SDLFile *)file mtuSize:(NSUInteger)mtuSize {
    NSUInteger maxBulkDataSize = [self.class testMaxBulkDataSizeForFile:file mtuSize:mtuSize];
    return (((file.fileSize - 1) / maxBulkDataSize) + 1);
}

/// Calculates the max size of the data that can be set in the bulk data field for a PutFile. The size of the binary header, JSON, and frame header must be taken into account in order to make sure the packet size does not exceed the max MTU size allowed by SDL Core.
/// @param file The file to be uploaded
/// @param mtuSize The max allowed size of packet generated for the SDLPutFile
/// @return The size of the bulk data that can be set in the PutFiles
+ (NSUInteger)testMaxBulkDataSizeForFile:(SDLFile *)file mtuSize:(NSUInteger)mtuSize {
    NSUInteger frameHeaderSize = [SDLProtocolHeader headerForVersion:(UInt8)[SDLGlobals sharedGlobals].protocolVersion.major].size;
    NSUInteger binaryHeaderSize = 12;

    SDLPutFile *putFile = [[SDLPutFile alloc] initWithFileName:file.name fileType:file.fileType persistentFile:file.persistent systemFile:NO offset:(UInt32)file.fileSize length:(UInt32)file.fileSize bulkData:file.data];
    putFile.crc = @(UINT32_MAX);
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:[putFile serializeAsDictionary:(Byte)[SDLGlobals sharedGlobals].protocolVersion.major] options:kNilOptions error:nil];
    NSUInteger maxJSONSize = jsonData.length;

    return mtuSize - (binaryHeaderSize + maxJSONSize + frameHeaderSize);
}

@end

QuickSpecBegin(SDLUploadFileOperationSpec)

describe(@"Streaming upload of data", ^{
    __block NSString *testFileName = nil;
    __block NSData *testFileData = nil;
    __block SDLFile *testFile = nil;
    __block SDLFileWrapper *testFileWrapper = nil;
    __block NSUInteger expectedNumberOfPutFiles = 0;

    __block TestConnectionManager *testConnectionManager = nil;
    __block SDLFileManager *mockFileManager = nil;
    __block SDLUploadFileOperation *testOperation = nil;

    __block BOOL successResult = NO;
    __block NSUInteger bytesAvailableResult = NO;
    __block NSError *errorResult = nil;

    __block int testMTUSize = 1024;

    beforeEach(^{
        [SDLGlobals sharedGlobals].maxHeadUnitProtocolVersion = [SDLVersion versionWithString:@"2.0.0"];
        // Since SDLGlobals is a singleton, the MTU size can be set by other test classes (i.e. the value returned can vary based on when these tests are run in relation to all the tests). Set the MTU size for this test suite to ensure the retrieved MTU size is the same every time this set of tests is run.
        [[SDLGlobals sharedGlobals] setDynamicMTUSize:(NSUInteger)testMTUSize forServiceType:SDLServiceTypeRPC];

        testFileName = nil;
        testFileData = nil;
        testFile = nil;
        testFileWrapper = nil;
        expectedNumberOfPutFiles = 0;

        testOperation = nil;
        testConnectionManager = [[TestConnectionManager alloc] init];
        mockFileManager = OCMClassMock([SDLFileManager class]);

        successResult = NO;
        bytesAvailableResult = NO;
        errorResult = nil;
    });

    describe(@"when the file is already on the head unit", ^{
        context(@"when not overwriting", ^{
            beforeEach(^{
                OCMStub([mockFileManager fileNeedsUpload:[OCMArg isNotNil]]).andReturn(NO);
            });

            it(@"should not send the upload RPCs and finish the operation", ^{
                testFileName = @"TestSmallMemory";
                testFileData = [@"test1234" dataUsingEncoding:NSUTF8StringEncoding];
                testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beFalse());
                    expect(bytesAvailable).to(equal(NSNotFound));
                    expect(error).toNot(beNil());
                }];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                expect(testConnectionManager.receivedRequests).to(haveCount(0));
                expect(testOperation.isFinished).to(beTrue());
            });
        });

        context(@"when overwriting", ^{
            beforeEach(^{
                OCMStub([mockFileManager fileNeedsUpload:[OCMArg any]]).andReturn(YES);
            });

            it(@"should send the upload RPCs", ^{
                testFileName = @"TestSmallMemory";
                testFileData = [@"test1234" dataUsingEncoding:NSUTF8StringEncoding];
                testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];
                testFile.overwrite = YES;

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beFalse());
                    expect(bytesAvailable).to(equal(NSNotFound));
                    expect(error).toNot(beNil());
                }];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                expect(testConnectionManager.receivedRequests).to(haveCount(1));
                expect(testOperation.isFinished).to(beFalse());
            });
        });
    });

    describe(@"when uploading data", ^{
        __block NSInteger spaceLeft = 0;
        __block SDLPutFileResponse *successResponse = nil;

        beforeEach(^{
            spaceLeft = 11212512;
            OCMStub([mockFileManager fileNeedsUpload:[OCMArg isNotNil]]).andReturn(YES);
        });

        context(@"data should be split into smaller packets if too large to send all at once", ^{
            it(@"should split the data from a short chunk of text in memory correctly", ^{
                testFileName = @"TestSmallMemory";
                testFileData = [@"test1234" dataUsingEncoding:NSUTF8StringEncoding];
                testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beTrue());
                    expect(bytesAvailable).to(equal(spaceLeft));
                    expect(error).to(beNil());
                }];

                expectedNumberOfPutFiles = [UploadFileOperationSpecHelpers testNumberOfPutFiles:testFile mtuSize:testMTUSize];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                NSArray<SDLPutFile *> *testPutFiles = testConnectionManager.receivedRequests;
                expect(@(testPutFiles.count)).to(equal(@(expectedNumberOfPutFiles)));

                [UploadFileOperationSpecHelpers testPutFiles:testPutFiles testFile:testFile mtuSize:testMTUSize];

                // Respond to each PutFile request
                for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                    successResponse = [[SDLPutFileResponse alloc] init];
                    successResponse.success = @YES;
                    successResponse.spaceAvailable = @(spaceLeft -= 1024);
                    [testConnectionManager respondToRequestWithResponse:successResponse requestNumber:i error:nil];
                }

                [SDLExpect SDLExpectWithTimeout:3 expectBlock:^{
                    expect(testOperation.finished).to(beTrue());
                    expect(testOperation.executing).to(beFalse());
                }];
            });

            it(@"should split the data from a large image in memory correctly", ^{
                testFileName = @"TestLargeMemory";
                UIImage *testImage = [UIImage imageNamed:@"testImagePNG" inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil];
                testFileData = UIImageJPEGRepresentation(testImage, 1.0);
                testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beTrue());
                    expect(bytesAvailable).to(equal(spaceLeft));
                    expect(error).to(beNil());
                }];

                expectedNumberOfPutFiles = [UploadFileOperationSpecHelpers testNumberOfPutFiles:testFile mtuSize:testMTUSize];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                NSArray<SDLPutFile *> *putFiles = testConnectionManager.receivedRequests;
                expect(@(putFiles.count)).to(equal(@(expectedNumberOfPutFiles)));
                [UploadFileOperationSpecHelpers testPutFiles:putFiles testFile:testFile mtuSize:testMTUSize];

                // Respond to each PutFile request
                for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                    successResponse = [[SDLPutFileResponse alloc] init];
                    successResponse.success = @YES;
                    successResponse.spaceAvailable = @(spaceLeft -= 1024);
                    [testConnectionManager respondToRequestWithResponse:successResponse requestNumber:i error:nil];
                }

                [SDLExpect SDLExpectWithTimeout:3 expectBlock:^{
                    expect(testOperation.finished).to(beTrue());
                    expect(testOperation.executing).to(beFalse());
                }];
            });

            it(@"should split the data from a small text file correctly", ^{
                testFileName = @"testFileJSON";
                NSString *textFilePath = [[NSBundle bundleForClass:[self class]] pathForResource:testFileName ofType:@"json"];
                NSURL *textFileURL = [[NSURL alloc] initFileURLWithPath:textFilePath];
                testFile = [SDLFile fileAtFileURL:textFileURL name:testFileName];
                testFileData = [[NSData alloc] initWithContentsOfURL:textFileURL];

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beTrue());
                    expect(bytesAvailable).to(equal(spaceLeft));
                    expect(error).to(beNil());
                }];

                expectedNumberOfPutFiles = [UploadFileOperationSpecHelpers testNumberOfPutFiles:testFile mtuSize:testMTUSize];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                NSArray<SDLPutFile *> *putFiles = testConnectionManager.receivedRequests;
                expect(@(putFiles.count)).to(equal(@(expectedNumberOfPutFiles)));
                [UploadFileOperationSpecHelpers testPutFiles:putFiles testFile:testFile mtuSize:testMTUSize];

                // Respond to each PutFile request
                for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                    successResponse = [[SDLPutFileResponse alloc] init];
                    successResponse.success = @YES;
                    successResponse.spaceAvailable = @(spaceLeft -= 1024);
                    [testConnectionManager respondToRequestWithResponse:successResponse requestNumber:i error:nil];
                }

                [SDLExpect SDLExpectWithTimeout:3 expectBlock:^{
                    expect(testOperation.finished).to(beTrue());
                    expect(testOperation.executing).to(beFalse());
                }];
            });

            it(@"should split the data from a large image file correctly", ^{
                NSString *fileName = @"testImagePNG";
                testFileName = fileName;
                NSString *imageFilePath = [[NSBundle bundleForClass:[self class]] pathForResource:fileName ofType:@"png"];
                NSURL *imageFileURL = [[NSURL alloc] initFileURLWithPath:imageFilePath];
                testFile = [SDLFile fileAtFileURL:imageFileURL name:fileName];
                testFileData = [[NSData alloc] initWithContentsOfURL:imageFileURL];

                testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                    expect(success).to(beTrue());
                    expect(bytesAvailable).to(equal(spaceLeft));
                    expect(error).to(beNil());
                }];

                expectedNumberOfPutFiles = [UploadFileOperationSpecHelpers testNumberOfPutFiles:testFile mtuSize:testMTUSize];

                testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
                [testOperation start];

                NSArray<SDLPutFile *> *putFiles = testConnectionManager.receivedRequests;
                expect(@(putFiles.count)).to(equal(@(expectedNumberOfPutFiles)));
                [UploadFileOperationSpecHelpers testPutFiles:putFiles testFile:testFile mtuSize:testMTUSize];

                // Respond to each PutFile request
                for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                    successResponse = [[SDLPutFileResponse alloc] init];
                    successResponse.success = @YES;
                    successResponse.spaceAvailable = @(spaceLeft -= 1024);
                    [testConnectionManager respondToRequestWithResponse:successResponse requestNumber:i error:nil];
                }

                [SDLExpect SDLExpectWithTimeout:3 expectBlock:^{
                    expect(testOperation.finished).to(beTrue());
                    expect(testOperation.executing).to(beFalse());
                }];
            });
        });
    });

    describe(@"when a response to the data upload comes back", ^{
        beforeEach(^{
            OCMStub([mockFileManager fileNeedsUpload:[OCMArg isNotNil]]).andReturn(YES);
            testFileName = @"TestLargeMemory";
            UIImage *testImage = [UIImage imageNamed:@"testImagePNG" inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil];
            testFileData = UIImageJPEGRepresentation(testImage, 1.0);
            testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];
            testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                successResult = success;
                bytesAvailableResult = bytesAvailable;
                errorResult = error;
            }];

            expectedNumberOfPutFiles = [UploadFileOperationSpecHelpers testNumberOfPutFiles:testFile mtuSize:testMTUSize];

            testConnectionManager = [[TestConnectionManager alloc] init];
            testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
            [testOperation start];
        });

        context(@"if data was sent successfully", ^{
            __block NSInteger spaceLeft = 0;
            __block SDLPutFileResponse *successResponse = nil;

            beforeEach(^{
                spaceLeft = 11212512;
            });

            it(@"should have called the completion handler with success only if all packets were sent successfully", ^{
                for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                    successResponse = [[SDLPutFileResponse alloc] init];
                    successResponse.success = @YES;
                    successResponse.spaceAvailable = @(spaceLeft -= 1024);
                    [testConnectionManager respondToRequestWithResponse:successResponse requestNumber:i error:nil];
                }

//                [SDLExpect SDLExpectWithTimeout:(SDLExpect.timeout + 3) expectBlock:^{
                [NSThread sleepForTimeInterval:1.0];
                    expect(successResult).to(beTrue());
                    expect(bytesAvailableResult).to(equal(spaceLeft));
                    expect(errorResult).to(beNil());

                    expect(testOperation.finished).to(beTrue());
                    expect(testOperation.executing).to(beFalse());
//                }];
            });
        });

        context(@"if data was not sent successfully", ^{
            __block SDLPutFileResponse *response = nil;
            __block NSString *responseErrorDescription = nil;
            __block NSString *responseErrorReason = nil;
            __block NSError *error = nil;
            __block NSInteger spaceLeft = 0;

            beforeEach(^{
                responseErrorDescription = nil;
                responseErrorReason = nil;
                spaceLeft = 11212512;
            });

            context(@"when the first packet is not successful", ^{
                beforeEach(^{
                    for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                        response = [[SDLPutFileResponse alloc] init];
                        response.spaceAvailable = @(spaceLeft -= 1024);

                        if (i == 0) {
                            // Only the first packet is sent unsuccessfully
                            response.success = @NO;
                            responseErrorDescription = @"some description";
                            responseErrorReason = @"some reason";
                            error = [NSError sdl_lifecycle_unknownRemoteErrorWithDescription:responseErrorDescription andReason:responseErrorReason];
                        } else  {
                            response.success = @YES;
                            error = nil;
                        }

                        [testConnectionManager respondToRequestWithResponse:response requestNumber:i error:error];
                    }
                });

                it(@"should have called the completion handler with error", ^{
                    [SDLExpect SDLExpectWithTimeout:SDLExpect.timeout expectBlock:^{
                        expect(errorResult.localizedDescription).to(match(responseErrorDescription));
                        expect(errorResult.localizedFailureReason).to(match(responseErrorReason));
                        expect(successResult).to(beFalse());
                    }];
                });
            });

            context(@"when the last packet is not successful", ^{
                it(@"should have called the completion handler with error", ^{
                    for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                        response = [[SDLPutFileResponse alloc] init];
                        response.spaceAvailable = @(spaceLeft -= 1024);

                        if (i == (expectedNumberOfPutFiles - 1)) {
                            // Only the last packet is sent unsuccessfully
                            response.success = @NO;
                            responseErrorDescription = @"some description";
                            responseErrorReason = @"some reason";
                            error = [NSError sdl_lifecycle_unknownRemoteErrorWithDescription:responseErrorDescription andReason:responseErrorReason];
                        } else  {
                            response.success = @YES;
                            error = nil;
                        }

                        [testConnectionManager respondToRequestWithResponse:response requestNumber:i error:error];
                    }

//                    [SDLExpect SDLExpectWithTimeout:SDLExpect.timeout expectBlock:^{
                    sleep(SDLExpect.timeout + 3);
                        expect(errorResult.localizedDescription).to(match(responseErrorDescription));
                        expect(errorResult.localizedFailureReason).to(match(responseErrorReason));
                        expect(successResult).to(beFalse());
//                    }];
                });
            });

            context(@"when all the packets are not successful", ^{
                it(@"should have called the completion handler with error if all packets were not sent successfully", ^{
                    for (int i = 0; i < expectedNumberOfPutFiles; i++) {
                        response = [[SDLPutFileResponse alloc] init];
                        response.success = @NO;
                        response.spaceAvailable = @(spaceLeft -= 1024);

                        responseErrorDescription = @"some description";
                        responseErrorReason = @"some reason";

                        [testConnectionManager respondToRequestWithResponse:response requestNumber:i error:[NSError sdl_lifecycle_unknownRemoteErrorWithDescription:responseErrorDescription andReason:responseErrorReason]];
                    }
//                    [SDLExpect SDLExpectWithTimeout:SDLExpect.timeout expectBlock:^{

                    [NSThread sleepForTimeInterval:1.0];
                    expect(errorResult.localizedDescription).to(match(responseErrorDescription));
                        expect(errorResult.localizedFailureReason).to(match(responseErrorReason));
                        expect(successResult).to(beFalse());
//                    }];
                });
            });
        });
    });

    describe(@"when an incorrect file url is passed", ^{
        beforeEach(^{
            OCMStub([mockFileManager fileNeedsUpload:[OCMArg any]]).andReturn(YES);
        });

        it(@"should have called the completion handler with an error", ^{
            NSString *fileName = @"testImagePNG";
            testFileName = fileName;
            NSString *imageFilePath = [[NSBundle bundleForClass:[self class]] pathForResource:fileName ofType:@"png"];
            NSURL *imageFileURL = [[NSURL alloc] initWithString:imageFilePath]; // This will fail because local file paths need to be init with initFileURLWithPath
            testFile = [SDLFile fileAtFileURL:imageFileURL name:fileName];

            testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                expect(success).to(beFalse());
                expect(error).to(equal([NSError sdl_fileManager_fileDoesNotExistError]));
            }];

            testConnectionManager = [[TestConnectionManager alloc] init];
            testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
            [testOperation start];
        });
    });

    describe(@"when empty data is passed", ^{
        beforeEach(^{
            OCMStub([mockFileManager fileNeedsUpload:[OCMArg any]]).andReturn(YES);
        });

        it(@"should have called the completion handler with an error", ^{
            testFileName = @"TestEmptyMemory";
            testFileData = [@"" dataUsingEncoding:NSUTF8StringEncoding];
            testFile = [SDLFile fileWithData:testFileData name:testFileName fileExtension:@"bin"];

            testFileWrapper = [SDLFileWrapper wrapperWithFile:testFile completionHandler:^(BOOL success, NSUInteger bytesAvailable, NSError * _Nullable error) {
                expect(error).to(equal([NSError sdl_fileManager_fileDoesNotExistError]));
                expect(success).to(beFalse());
            }];

            testConnectionManager = [[TestConnectionManager alloc] init];
            testOperation = [[SDLUploadFileOperation alloc] initWithFile:testFileWrapper connectionManager:testConnectionManager fileManager:mockFileManager];
            [testOperation start];
        });
    });
});

QuickSpecEnd
